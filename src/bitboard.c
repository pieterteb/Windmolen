#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>

#include "bitboard.h"
#include "types.h"
#include "util.h"



Bitboard piece_base_attack_table[PIECE_TYPE_COUNT][SQUARE_COUNT] = { 0 };

#define BISHOP_ENTRY_COUNT 5248
#define ROOK_ENTRY_COUNT 102400

Bitboard slider_attack_table[BISHOP_ENTRY_COUNT + ROOK_ENTRY_COUNT];

static struct Magic bishop_magic_table[SQUARE_COUNT];
static struct Magic rook_magic_table[SQUARE_COUNT];


static Bitboard sliding_attacks(PieceType piece_type, Square square, Bitboard occupancy);
static void initialise_magics(PieceType piece_type);


static Bitboard step_safe(Square square, Direction step) {
    Square to = square + (Square)step;

    return is_valid_square(to) ? square_bitboard(to) : BITBOARD_EMPTY;
}


void initialise_bitboards() {
    initialise_magics(PIECE_TYPE_BISHOP);
    initialise_magics(PIECE_TYPE_ROOK);

    for (Square square = SQUARE_A1; square <= SQUARE_H8; ++square) {
        Bitboard square_bitboard = SQUARE_BITBOARD(square);

        piece_base_attack_table[PIECE_WHITE_PAWN][square] = PAWN_ATTACKS_BITBOARD(square_bitboard, COLOR_WHITE);
        piece_base_attack_table[PIECE_BLACK_PAWN][square] = PAWN_ATTACKS_BITBOARD(square_bitboard, COLOR_BLACK);

        const Direction knight_steps[8] = {
            DIRECTION_NORTH + DIRECTION_NORTHEAST, DIRECTION_EAST  + DIRECTION_NORTHEAST,
            DIRECTION_EAST  + DIRECTION_SOUTHEAST, DIRECTION_SOUTH + DIRECTION_SOUTHEAST,
            DIRECTION_SOUTH + DIRECTION_SOUTHWEST, DIRECTION_WEST  + DIRECTION_SOUTHWEST,
            DIRECTION_WEST  + DIRECTION_NORTHWEST, DIRECTION_NORTH + DIRECTION_NORTHWEST
        };
        const Direction king_steps[8] = {
            DIRECTION_NORTH, DIRECTION_NORTHEAST,
            DIRECTION_EAST,  DIRECTION_SOUTHEAST,
            DIRECTION_SOUTH, DIRECTION_SOUTHWEST,
            DIRECTION_WEST,  DIRECTION_NORTHWEST
        };
        for (size_t i = 0; i < 8; ++i) {
            piece_base_attack_table[PIECE_TYPE_KNIGHT][square] |= step_safe(square, knight_steps[i]);
            piece_base_attack_table[PIECE_TYPE_KING][square] |= step_safe(square, king_steps[i]);
        }

        piece_base_attack_table[PIECE_TYPE_BISHOP][square] = slider_attacks(PIECE_TYPE_BISHOP, square, BITBOARD_EMPTY);
        piece_base_attack_table[PIECE_TYPE_ROOK][square] = slider_attacks(PIECE_TYPE_ROOK, square, BITBOARD_EMPTY);

        piece_base_attack_table[PIECE_TYPE_QUEEN][square] = piece_base_attack_table[PIECE_TYPE_BISHOP][square] | piece_base_attack_table[PIECE_TYPE_ROOK][square];
    }
}


static Bitboard sliding_attacks(PieceType piece_type, Square square, Bitboard occupancy) {
    assert(is_valid_square(square) && (piece_type == PIECE_TYPE_BISHOP || piece_type == PIECE_TYPE_ROOK));

    Bitboard square_bitboard = SQUARE_BITBOARD(square);

    Direction bishop_directions[4] = { DIRECTION_NORTHEAST, DIRECTION_SOUTHEAST, DIRECTION_SOUTHWEST, DIRECTION_NORTHWEST };
    Direction rook_directions[4] = { DIRECTION_NORTH, DIRECTION_EAST, DIRECTION_SOUTH, DIRECTION_WEST };
    Direction* directions = (piece_type == PIECE_TYPE_BISHOP) ? bishop_directions : rook_directions;

    Bitboard attacks = BITBOARD_EMPTY;

    for (size_t i = 0; i < 4; ++i) {
        Direction direction = directions[i];

        for (Bitboard bitboard = SHIFT_BITBOARD(square_bitboard, direction); bitboard; bitboard = SHIFT_BITBOARD(bitboard, direction)) {
            attacks |= bitboard;
            if (bitboard & occupancy) break;
        }
    }

    return attacks;
}

static void initialise_magics(PieceType piece_type) {
    assert(piece_type == PIECE_TYPE_BISHOP || piece_type == PIECE_TYPE_ROOK);

    // Generated by Windmolen/tools/magic_finder/magic_finder with seed: 1758127450.
    const Bitboard bishop_magics[SQUARE_COUNT] = {
        0x0308880481840300, 0x0086860c03020000, 0x8008461404200004, 0x0004040082300001, 0x00c4030801211210, 0x0011050840006004, 0x03040c01080a0040, 0x8154404804212000,
        0x0004081014080540, 0x0414200811010362, 0x4000210842808006, 0x1601040400801000, 0x8032020210204800, 0x0c20050320100402, 0x2010804208200800, 0x08210100c8442403,
        0x8024802088020800, 0x0020003408218524, 0x3008104408421201, 0x800482080a004200, 0x020184b400a0004b, 0x0041000181601200, 0x0014808048081804, 0x6006000081440200,
        0x0808204040840540, 0x4008840008010804, 0x01006c1008004400, 0x20020c8008008100, 0x4011010040104000, 0x0010010281808280, 0x0008020009010142, 0x000208502e050080,
        0x001002a000080810, 0x0008080b00088604, 0x0000402080100102, 0x0028600800410106, 0x0008520020020080, 0x0020080282004141, 0x20049484050a0714, 0x4402840080010284,
        0x2002211040089800, 0x0802820130002000, 0x2003011090000200, 0x2410426018018100, 0x1002c00c18200300, 0x0001202800800040, 0x0002180201800c02, 0x6510118a83900300, 0x0042111c22401068, 0x2050842111104002, 0x0450208201410080, 0x0002224842021940, 0x204009a002440000, 0x1e0514200c050002, 0x0020431005050000, 0x0002080214004009,
        0x102200c448080800, 0x98001108848c2004, 0x000000a422941000, 0x0500030004420220, 0x1000004010020200, 0x0002001020022c20, 0x0000400206020200, 0x0008080808002420
    };
    const Bitboard rook_magics[SQUARE_COUNT] = {
        0x0010000028040920, 0x00a0841008400204, 0x0a18100302042000, 0x8401043008020085, 0x00340c4801108204, 0x800100b044088200, 0x0006050140102880, 0x0020018000800021,
        0x000203060000c440, 0x4040404010002000, 0x4201004030200101, 0x10420008b0204200, 0x000200208a003034, 0x000200020008b044, 0x800c008408121049, 0x4204100000000040,
        0x400241000c002204, 0x0040010020450080, 0x0000260012420080, 0x0000220012004208, 0x0000050008001100, 0x4814008042008004, 0x05004400021001b8, 0x0200220021800003,
        0x00028082060002d1, 0x0810500840002000, 0x1615004100112000, 0x0080100080080080, 0x0108008080040008, 0x020a001200108408, 0x89410001001a0004, 0x20010a0200518044, 0x40000000041021e0, 0x6010002004400440, 0x0420802000805000, 0x300108b001002100, 0x8001011005001800, 0x0000420080800c00, 0x0003000409000200, 0x02e0083002000000, 0x7010000804420202, 0x4000500820034000, 0x0008600101410012, 0x2001043000090020, 0x0001004408010010, 0x0002001005020018, 0x0008181130040002, 0x0200000002020000, 0x0008412004003208, 0x0090942002400480, 0x0202820125401200, 0x0000a01001000900, 0x811008000d001100, 0x820a011018840200, 0xc0c0081009420400, 0x003000101180c100, 0x0000008000040800, 0x0408409020840220, 0x0020412410061804, 0x0241300800842600, 0x2c08250208440080, 0x0004004081042201, 0x0000470111220080, 0x0000103000128000
    };
    const Bitboard* magics = (piece_type == PIECE_TYPE_BISHOP) ? bishop_magics : rook_magics;
    struct Magic* magic_table = (piece_type == PIECE_TYPE_BISHOP) ? bishop_magic_table : rook_magic_table;

    for (Square square = SQUARE_A1; square <= SQUARE_H8; ++square) {
        const Bitboard edges = ((FILE_A_BITBOARD | FILE_H_BITBOARD) & ~file_bitboard(file_from_square(square)))
                             | ((RANK_1_BITBOARD | RANK_8_BITBOARD) & ~rank_bitboard(rank_from_square(square)));

        if (square == SQUARE_A1)
            magic_table[square].attack_table = slider_attack_table + ((piece_type == PIECE_TYPE_ROOK) ? BISHOP_ENTRY_COUNT : 0);
        else
            magic_table[square].attack_table = magic_table[square - 1].attack_table + (1ULL << (64U - magic_table[square - 1].shift));

        magic_table[square].mask = sliding_attacks(piece_type, square, BITBOARD_EMPTY) & ~edges;
        magic_table[square].shift = 64U - (unsigned)popcount64(magic_table[square].mask);
        magic_table[square].factor = magics[square];

        Bitboard subset = 0;
        do {
            size_t index = magic_index(piece_type, square, subset);
            magic_table[square].attack_table[index] = sliding_attacks(piece_type, square, subset);
            subset = (subset - magic_table[square].mask) & magic_table[square].mask;
        } while (subset);
    }
}

#undef BISHOP_ENTRY_COUNT
#undef ROOK_ENTRY_COUNT

unsigned magic_index(PieceType piece_type, Square square, Bitboard occupancy) {
    assert((piece_type == PIECE_TYPE_BISHOP || piece_type == PIECE_TYPE_ROOK) && is_valid_square(square));

    const struct Magic* magic_table = (piece_type == PIECE_TYPE_BISHOP) ? bishop_magic_table : rook_magic_table;

    return (unsigned)(((occupancy & magic_table[square].mask) * magic_table[square].factor) >> magic_table[square].shift);
}

extern Bitboard slider_attacks(PieceType piece_type, Square square, Bitboard occupancy) {
    assert((piece_type == PIECE_TYPE_BISHOP || piece_type == PIECE_TYPE_ROOK) && is_valid_square(square));

    const struct Magic* magic_table = (piece_type == PIECE_TYPE_BISHOP) ? bishop_magic_table : rook_magic_table;

    return magic_table[square].attack_table[magic_index(piece_type, square, occupancy)];
}


char* bitboard_to_string(Bitboard bitboard, size_t* size_out) {
    char* string = malloc(4096 * sizeof(*string));
    size_t size = (size_t)sprintf(string, "+---+---+---+---+---+---+---+---+\n");

    for (Rank rank = RANK_8; rank >= RANK_1; --rank) {
        for (File file = FILE_A; file <= FILE_H; ++file)
            size += (size_t)sprintf(string + size, (bitboard & coordinates_bitboard(file, rank)) ? "| X " : "|   ");

        size += (size_t)sprintf(string + size, "| %" PRId8 "\n+---+---+---+---+---+---+---+---+\n", rank + 1);
    }
    size += (size_t)sprintf(string + size, "  a   b   c   d   e   f   g   h\n");
    size += (size_t)sprintf(string + size, "Hex: %#018" PRIx64 "\n", bitboard);

    string = realloc(string, size + 1); // +1 for \0.

    if (size_out != NULL)
        *size_out = size;
    
    return string;
}
