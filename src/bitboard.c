#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>

#include "bitboard.h"
#include "types.h"
#include "util.h"



static Bitboard piece_base_attack_table[PIECE_TYPE_COUNT][SQUARE_COUNT] = { 0 };
static Bitboard slider_attack_table[BISHOP_ENTRY_COUNT + ROOK_ENTRY_COUNT];

Bitboard piece_base_attack(PieceType piece_type, Square square) {
    assert(is_valid_piece_type(piece_type) && is_valid_square(square));

    return piece_base_attack_table[piece_type][square];
}

static struct Magic bishop_magic_table[SQUARE_COUNT];
static struct Magic rook_magic_table[SQUARE_COUNT];


static Bitboard sliding_attacks(PieceType piece_type, Square square, Bitboard occupancy);
static void initialise_magics(PieceType piece_type);


static Bitboard step_safe(Square from, Direction step) {
    assert(is_valid_square(from));

    Square to = from + (Square)step;
    if (!is_valid_square(to))
        return EMPTY_BITBOARD;

    int rank_difference = abs(rank_from_square(to) - rank_from_square(from));
    int file_difference = abs(file_from_square(to) - file_from_square(from));

    return (rank_difference <= 2 && file_difference <= 2) ? square_bitboard(to) : EMPTY_BITBOARD;
}


void initialise_bitboards() {
    initialise_magics(PIECE_TYPE_BISHOP);
    initialise_magics(PIECE_TYPE_ROOK);

    for (Square square = SQUARE_A1; square <= SQUARE_H8; ++square) {
        Bitboard square_bitboard = SQUARE_BITBOARD(square);

        piece_base_attack_table[PIECE_WHITE_PAWN][square] = PAWN_ATTACKS_BITBOARD(square_bitboard, COLOR_WHITE);
        piece_base_attack_table[PIECE_BLACK_PAWN][square] = PAWN_ATTACKS_BITBOARD(square_bitboard, COLOR_BLACK);

        const Direction knight_steps[8] = {
            DIRECTION_NORTH + DIRECTION_NORTHEAST, DIRECTION_EAST  + DIRECTION_NORTHEAST,
            DIRECTION_EAST  + DIRECTION_SOUTHEAST, DIRECTION_SOUTH + DIRECTION_SOUTHEAST,
            DIRECTION_SOUTH + DIRECTION_SOUTHWEST, DIRECTION_WEST  + DIRECTION_SOUTHWEST,
            DIRECTION_WEST  + DIRECTION_NORTHWEST, DIRECTION_NORTH + DIRECTION_NORTHWEST
        };
        const Direction king_steps[8] = {
            DIRECTION_NORTH, DIRECTION_NORTHEAST,
            DIRECTION_EAST,  DIRECTION_SOUTHEAST,
            DIRECTION_SOUTH, DIRECTION_SOUTHWEST,
            DIRECTION_WEST,  DIRECTION_NORTHWEST
        };
        for (size_t i = 0; i < 8; ++i) {
            piece_base_attack_table[PIECE_TYPE_KNIGHT][square] |= step_safe(square, knight_steps[i]);
            piece_base_attack_table[PIECE_TYPE_KING][square] |= step_safe(square, king_steps[i]);
        }

        piece_base_attack_table[PIECE_TYPE_BISHOP][square] = slider_attacks(PIECE_TYPE_BISHOP, square, EMPTY_BITBOARD);
        piece_base_attack_table[PIECE_TYPE_ROOK][square] = slider_attacks(PIECE_TYPE_ROOK, square, EMPTY_BITBOARD);

        piece_base_attack_table[PIECE_TYPE_QUEEN][square] = piece_base_attack_table[PIECE_TYPE_BISHOP][square] | piece_base_attack_table[PIECE_TYPE_ROOK][square];
    }
}


static Bitboard sliding_attacks(PieceType piece_type, Square square, Bitboard occupancy) {
    assert(is_valid_square(square) && (piece_type == PIECE_TYPE_BISHOP || piece_type == PIECE_TYPE_ROOK));

    Bitboard square_bitboard = SQUARE_BITBOARD(square);

    Direction bishop_directions[4] = { DIRECTION_NORTHEAST, DIRECTION_SOUTHEAST, DIRECTION_SOUTHWEST, DIRECTION_NORTHWEST };
    Direction rook_directions[4] = { DIRECTION_NORTH, DIRECTION_EAST, DIRECTION_SOUTH, DIRECTION_WEST };
    Direction* directions = (piece_type == PIECE_TYPE_BISHOP) ? bishop_directions : rook_directions;

    Bitboard attacks = EMPTY_BITBOARD;

    for (size_t i = 0; i < 4; ++i) {
        Direction direction = directions[i];

        for (Bitboard bitboard = SHIFT_BITBOARD(square_bitboard, direction); bitboard; bitboard = SHIFT_BITBOARD(bitboard, direction)) {
            attacks |= bitboard;
            if (bitboard & occupancy) break;
        }
    }

    return attacks;
}

static void initialise_magics(PieceType piece_type) {
    assert(piece_type == PIECE_TYPE_BISHOP || piece_type == PIECE_TYPE_ROOK);

    // Generated by Windmolen/tools/magic_finder/magic_finder with seed: 1758127450.
    const Bitboard bishop_magics[SQUARE_COUNT] = {
        0x0308880481840300, 0x0086860c03020000, 0x8008461404200004, 0x0004040082300001, 0x00c4030801211210, 0x0011050840006004, 0x03040c01080a0040, 0x8154404804212000,
        0x0004081014080540, 0x0414200811010362, 0x4000210842808006, 0x1601040400801000, 0x8032020210204800, 0x0c20050320100402, 0x2010804208200800, 0x08210100c8442403,
        0x8024802088020800, 0x0020003408218524, 0x3008104408421201, 0x800482080a004200, 0x020184b400a0004b, 0x0041000181601200, 0x0014808048081804, 0x6006000081440200,
        0x0808204040840540, 0x4008840008010804, 0x01006c1008004400, 0x20020c8008008100, 0x4011010040104000, 0x0010010281808280, 0x0008020009010142, 0x000208502e050080,
        0x001002a000080810, 0x0008080b00088604, 0x0000402080100102, 0x0028600800410106, 0x0008520020020080, 0x0020080282004141, 0x20049484050a0714, 0x4402840080010284,
        0x2002211040089800, 0x0802820130002000, 0x2003011090000200, 0x2410426018018100, 0x1002c00c18200300, 0x0001202800800040, 0x0002180201800c02, 0x6510118a83900300,
        0x0042111c22401068, 0x2050842111104002, 0x0450208201410080, 0x0002224842021940, 0x204009a002440000, 0x1e0514200c050002, 0x0020431005050000, 0x0002080214004009,
        0x102200c448080800, 0x98001108848c2004, 0x000000a422941000, 0x0500030004420220, 0x1000004010020200, 0x0002001020022c20, 0x0000400206020200, 0x0008080808002420
    };
    const Bitboard rook_magics[SQUARE_COUNT] = {
        0x2d0010c120800100, 0x8240024020001002, 0x1200108008422200, 0x0080080080049000, 0x030003000c300800, 0x820010040802000d, 0x020002000100880c, 0x2100104080210002,
        0x0030800884400068, 0x8001002080400100, 0x0001002000410014, 0x2100805000810800, 0x0040800401180080, 0x2048800c00920080, 0x000900046a000100, 0x080080188008c100,
        0x0000208000400080, 0x0001010040082180, 0x2200808020021004, 0x4240818008001000, 0x0084018008001c80, 0x0000808042000400, 0x0000040089020810, 0x0521420008804401,
        0x024000a480004880, 0x0468400080200580, 0x0040124100200104, 0x0408900100082102, 0x4002580080800c00, 0x6082001600085084, 0x6014101400810218, 0x0001124200108411,
        0x0100284004800080, 0x0010082000404008, 0x1041526001004300, 0x0000080080801002, 0x0016000c22001028, 0x0002000832001004, 0x406010069c000108, 0x3084040482002841,
        0x010c802040008010, 0xa010002000414001, 0x3520040200101000, 0x0000404812020020, 0x4062080004008080, 0x8302001024020048, 0x600010c218040017, 0x4409000084410012,
        0x001080a502004200, 0x0008950200a04200, 0x004112024080aa00, 0x0094406012004a00, 0x8003000408025100, 0x0820808200040080, 0x1300024108102400, 0x0001000040820100,
        0x4000210016008042, 0x0002008057006042, 0x0000484091002001, 0x084034883000a101, 0x1403004608004c11, 0x0032000804900922, 0x40220013042800a2, 0x0804240284310046
    };
    const Bitboard* magics = (piece_type == PIECE_TYPE_BISHOP) ? bishop_magics : rook_magics;
    struct Magic* magic_table = (piece_type == PIECE_TYPE_BISHOP) ? bishop_magic_table : rook_magic_table;

    for (Square square = SQUARE_A1; square <= SQUARE_H8; ++square) {
        const Bitboard edges = ((FILE_A_BITBOARD | FILE_H_BITBOARD) & ~file_bitboard(file_from_square(square)))
                             | ((RANK_1_BITBOARD | RANK_8_BITBOARD) & ~rank_bitboard(rank_from_square(square)));

        if (square == SQUARE_A1)
            magic_table[square].attack_table = slider_attack_table + ((piece_type == PIECE_TYPE_BISHOP) ? 0 : BISHOP_ENTRY_COUNT);
        else
            magic_table[square].attack_table = magic_table[square - 1].attack_table + (1ULL << (64U - magic_table[square - 1].shift));

        magic_table[square].mask = sliding_attacks(piece_type, square, EMPTY_BITBOARD) & ~edges;
        magic_table[square].shift = 64U - (unsigned)popcount64(magic_table[square].mask);
        magic_table[square].factor = magics[square];

        Bitboard subset = 0;
        do {
            size_t index = magic_index(piece_type, square, subset);
            magic_table[square].attack_table[index] = sliding_attacks(piece_type, square, subset);
            subset = (subset - magic_table[square].mask) & magic_table[square].mask;
        } while (subset);
    }
}

#undef BISHOP_ENTRY_COUNT
#undef ROOK_ENTRY_COUNT

unsigned magic_index(PieceType piece_type, Square square, Bitboard occupancy) {
    assert((piece_type == PIECE_TYPE_BISHOP || piece_type == PIECE_TYPE_ROOK) && is_valid_square(square));

    const struct Magic* magic_table = (piece_type == PIECE_TYPE_BISHOP) ? bishop_magic_table : rook_magic_table;

    return (unsigned)(((occupancy & magic_table[square].mask) * magic_table[square].factor) >> magic_table[square].shift);
}

extern Bitboard slider_attacks(PieceType piece_type, Square square, Bitboard occupancy) {
    assert((piece_type == PIECE_TYPE_BISHOP || piece_type == PIECE_TYPE_ROOK) && is_valid_square(square));

    const struct Magic* magic_table = (piece_type == PIECE_TYPE_BISHOP) ? bishop_magic_table : rook_magic_table;

    return magic_table[square].attack_table[magic_index(piece_type, square, occupancy)];
}


char* bitboard_to_string(Bitboard bitboard, size_t* size_out) {
    char* string = malloc(4096 * sizeof(*string));
    size_t size = (size_t)sprintf(string, "+---+---+---+---+---+---+---+---+\n");

    for (Rank rank = RANK_8; rank >= RANK_1; --rank) {
        for (File file = FILE_A; file <= FILE_H; ++file)
            size += (size_t)sprintf(string + size, (bitboard & coordinates_bitboard(file, rank)) ? "| X " : "|   ");

        size += (size_t)sprintf(string + size, "| %" PRId8 "\n+---+---+---+---+---+---+---+---+\n", rank + 1);
    }
    size += (size_t)sprintf(string + size, "  a   b   c   d   e   f   g   h\n");
    size += (size_t)sprintf(string + size, "Hex: %#018" PRIx64 "\n", bitboard);

    string = realloc(string, size + 1); // +1 for \0.

    if (size_out != NULL)
        *size_out = size;
    
    return string;
}
